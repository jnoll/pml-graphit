{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}

-- automatically generated by BNF Converter
module Main where

import Data.List (intercalate)
import Data.Maybe (fromMaybe)

import Formal.PML.ErrM
import Formal.PML.Subtree (selectSubtree, PML(..))
import Formal.PML.PrintPML (Print(..), parseContents)
import Formal.PML.PrintUML (GraphOptions(..), GraphType(..), defGraphOptions)

import System.Console.CmdArgs
import System.Environment (getArgs, getProgName)
import System.Exit (exitFailure, exitSuccess)
import System.IO (stdin, hGetContents)


-- Main entry point

data Options = Options {
      opt_agents :: Bool
    , opt_requires :: Bool
    , opt_provides :: Bool
    , opt_depth :: Int
    , opt_color :: [(String, String)]
    , opt_files :: [String]
    , opt_subtree ::  String
    , opt_swimlanes :: Bool
    , opt_width :: Int
} deriving (Data, Typeable, Show)

printPML :: Print a => Options -> a -> [String]
printPML opts a = if opt_agents opts then prtAgents a
                  else if opt_requires opts then prtRequires a
                  else if opt_provides opts then prtProvides a
                  else let color = opt_color opts 
                           opt'  = defGraphOptions { gopt_graphtype = if (opt_swimlanes opts) then Swimlanes else Partitions
                                                   , gopt_color =  color
                                                   , gopt_prunedepth = opt_depth opts
                                                   , gopt_textwidth = opt_width opts 
                                                   }
                       in prtUML opt' a




-- Print a process- or sub-tree.
showTree :: (Show a, Print a) => Options -> a -> IO ()
showTree opts tree = putStrLn $ intercalate "\n" $ printPML opts tree


runContents :: Options -> String -> IO ()
runContents opt s = case parseContents s of
           Bad s    -> do putStrLn $ "error: " ++ s

           Ok  tree -> do case selectSubtree (opt_subtree opt) tree of 
                            Just st   -> showTree opt st
                            otherwise -> showTree opt tree


runFile :: Options -> FilePath -> IO ()
runFile t f = readFile f >>= runContents t 

run :: Options -> IO ()
run opts = 
    if length (opt_files opts) > 0 then
        mapM_ (runFile opts) (opt_files opts)
    else
        getContents >>= runContents opts 



defaultOptions :: Options
defaultOptions = Options {
            opt_agents    = False &= typ "Boolean"            &= help "output list of agents"                  &= name "agents"
          , opt_requires  = False &= typ "Boolean"            &= help "output list of required resources"      &= name "requires"
          , opt_provides  = False &= typ "Boolean"            &= help "output list of provided resources"      &= name "provides"
          , opt_color     = []    &= typ "PML-element,Color"  &= help "named item should have specified color (no space after comma)" &= name "color"
          , opt_depth     = 0     &= typ "Int"                &= help "depth at which to prune subtree"        &= name "depth"
          , opt_files     = def   &= typFile &= args
          , opt_subtree   = def   &= typ "subtree"            &= help "select subtree"                         &= name "subtree"
          , opt_swimlanes = False &= typ "Boolean"            &= help "plot in swimlanes"                      &= name "swim"
          , opt_width     = 10    &= typ "Int"                &= help "text width for labels/descriptions"     &= name "width"
          }
          &= summary "pml-graphit v0.1, (C) 2016 John Noll"
          &= program "main"

main :: IO ()
main = do
    args <- cmdArgs defaultOptions
    run args

