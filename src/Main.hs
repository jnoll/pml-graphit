{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}

-- automatically generated by BNF Converter
module Main where

import Control.Monad.Reader (runReader)
import Data.List (intercalate, intersperse)
import Data.Maybe (fromMaybe)

import Formal.PML.Subtree (selectSubtree, PML(..))
import Formal.PML.PrintUML -- (printUML, Print(..))
import Formal.PML.LexPML
import Formal.PML.ParPML
import Formal.PML.SkelPML
--import Formal.PML.PrintPML
import Formal.PML.AbsPML
import Formal.PML.ErrM

import System.Console.CmdArgs
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import System.IO ( stdin, hGetContents )


type ParseFun a = [Token] -> Err a

myLLexer = myLexer

putStrV :: String -> IO ()
putStrV s = putStrLn s

runFile :: (Print a, PML a, Show a) => Options -> ParseFun a -> FilePath -> IO ()
runFile t p f = putStrLn f >> readFile f >>= runContents t p

showTree :: (Show a, Print a, PML a) => Options -> a -> IO ()
showTree opt tree = 
  let color = opt_color opt 
      opt'  = defGraphOptions { gopt_graphtype = if (opt_swimlanes opt) then Swimlanes else Partitions
                              , gopt_color =  color
                              , gopt_prunedepth = opt_depth opt
                              , gopt_textwidth = opt_width opt 
                              }
  in putStrLn $ intercalate "\n" $
     case selectSubtree (opt_subtree opt) tree of
                    Just st'@(PrimAct  (ID id) _ _)        -> runReader (printUML'' st') opt'
                    Just st'@(PrimBr   (OpNmId (ID id)) _) -> runReader (printUML'' st') opt'
                    Just st'@(PrimSeln (OpNmId (ID id)) _) -> runReader (printUML'' st') opt'
                    Just st'@(PrimIter (OpNmId (ID id)) _) -> runReader (printUML'' st') opt'
                    Just st'@(PrimSeq  (OpNmId (ID id)) _) -> runReader (printUML'' st') opt'
                    Just st'@(PrimTask (OpNmId (ID id)) _) -> runReader (printUML'' st') opt'
                    Just st'                               -> runReader (printUML'' st') opt'
                    otherwise -> runReader (printUML tree) opt'
     


runContents :: (Print a, PML a, Show a) => Options -> ParseFun a -> String -> IO ()
runContents opt p s = let ts = myLLexer s in case p ts of
           Bad s    -> do putStrLn "\nParse Failed...\n"
                          putStrV  "Tokens:"
                          putStrV  $ show ts
                          putStrLn s
                          exitFailure
           Ok  tree -> do 
             showTree opt tree
             exitSuccess

run :: Options -> IO ()
run opts = 
    if length (opt_files opts) > 0 then
        mapM_ (runFile opts pPROCESS) (opt_files opts)
    else
        getContents >>= runContents opts pPROCESS 


data Options = Options {
      opt_swimlanes :: Bool
    , opt_depth :: Int
    , opt_color :: [(String, String)]
    , opt_files :: [String]
    , opt_subtree ::  String
    , opt_width :: Int
} deriving (Data, Typeable, Show)

defaultOptions :: Options
defaultOptions = Options {
            opt_swimlanes = False &= typ "Boolean"            &= help "plot in swimlanes"                      &= name "swim"
          , opt_color     = []    &= typ "(PML element, Color)" &= help "named item should have specified color" &= name "color"
          , opt_depth     = 0     &= typ "Int"                &= help "depth at which to prune subtree"        &= name "depth"
          , opt_files     = def   &= typFile &= args
          , opt_subtree   = def   &= typ "subtree"            &= help "select subtree"                         &= name "subtree"
          , opt_width     = 10    &= typ "Int"                &= help "text width for labels/descriptions"     &= name "width"
          }
          &= summary "pml-graphit v0.1, (C) 2016 John Noll"
          &= program "main"

main :: IO ()
main = do
    args <- cmdArgs defaultOptions
    run args

