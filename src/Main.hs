{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}

-- automatically generated by BNF Converter
module Main where

import Control.Monad.Reader (runReader)
import Data.List (intercalate, intersperse)
import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )

import Formal.PML.PrintUML -- (printUML, Print(..))
import Formal.PML.LexPML
import Formal.PML.ParPML
import Formal.PML.SkelPML
--import Formal.PML.PrintPML
import Formal.PML.AbsPML
import Formal.PML.ErrM
import WithCli

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

putStrV :: String -> IO ()
putStrV s = putStrLn s

runFile :: (Print a, Show a) => Options -> ParseFun a -> FilePath -> IO ()
runFile t p f = putStrLn f >> readFile f >>= runContents t p

showTree :: (Show a, Print a) => Options -> a -> IO ()
showTree opt tree = 
    let color = case opt_color opt of Just c -> (read  $ c :: [(String, String)]) 
                                      otherwise -> []
    in putStrLn $ intercalate "\n" $ runReader (printUML tree) defGraphOptions { gopt_graphtype = if (opt_swimlanes opt) then Swimlanes else Partitions
                                                                               , gopt_color =  color}

runContents :: (Print a, Show a) => Options -> ParseFun a -> String -> IO ()
runContents opt p s = let ts = myLLexer s in case p ts of
           Bad s    -> do putStrLn "\nParse              Failed...\n"
                          putStrV  "Tokens:"
                          putStrV  $ show ts
                          putStrLn s
                          exitFailure
           Ok  tree -> do showTree opt tree
                          exitSuccess



run :: Options -> IO ()
run opts = 
    if length (opt_files opts) > 0 then
        mapM_ (runFile opts pPROCESS) (opt_files opts)
    else
        getContents >>= runContents opts pPROCESS 


usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (no arguments)  Parse stdin."
    , "  (files)         Parse content of files."
    , "  --swim          Produce swimlanes graph."
    ]
  exitFailure

data Options = Options {
      opt_swimlanes :: Bool
    , opt_select :: Maybe String
    , opt_files :: [String]
    , opt_color :: Maybe String
} deriving (Show, Generic, HasArguments)

main :: IO ()
main = withCliModified [ AddShortOption "swimlanes" 's'
                       , RenameOption "opt_swimlanes" "swim"
                       , AddShortOption "color" 'c' 
                       , RenameOption "opt_color" "color"
                       , UseForPositionalArguments "opt_files" "filenames"
                       ] run

